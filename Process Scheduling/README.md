출처 : 뇌를 자극하는 윈도우즈 시스템 프로그래밍

# 프로세스의 스케줄링(Scheduling)

* 실행중인 모든 프로세스에게 CPU에 의해 실행 될 수 있는 작업이 필요하고, 멀티프로세스를 지원하는 OS에서 담당.   
* OS 중에서도 일부분에 해당하는 스케줄러가 담당      
* 일반 OS와  리얼타임 OS의 차이   
-> RTOS와 일반 OS의 차이는 응답속도   
-> RTOS는 일반 OS보다 응답성이 좋다.(빠르다)   
-> 일반 OS는 범용적인 사용을 위해 디자인됨   
-> 즉, Windows나 Linux는 특수 목적이 있는 OS가 아님   
-> 반면 RTOS는 사용 영역이 제한적이며, 범용적인 OS보다 하는 일이 적다.   
-> 시키지 않은 일은 하지 않고, 프로세스 전력 소모를 최소화함.   
-> 따라서, RTOS라고 해서 일반 OS에 비해 속도가 빠른것이 아니고 사용 목적이 구체적이고 제한적(단순하게 디자인됨)이어서 일반 OS보다 가벼워 "응답성"이 좋은것이다.   

## Soft RTOS vs Hard RTOS
* RTOS와 일반 OS는 별반 차이가 없고, RTOS가 하는 일이 특화되어 응답성이 일반 OS에 비해 좋은것 뿐.   
* 이러한 RTOS를 Soft RTOS라하고 우리 대부분이 접하는 RTOS가 이것임.   
* 전통적인 의미의 RTOS는 Hard RTOS.   
* Hard RTOS는 응답성이 좋은 정도를 넘어서 데드라인이 크리티컬 하다. 자동차와 같이 생명과 관련된 곳에 사용됨.   
* 단순 CPU 속도가 빠르다고 만족되는 것이 아니라 Hard RTOS를 디자인 하는 것은 어렵다.   
* 일반 OS와 전혀 다른 알고리즘으로 스케줄러가 디자인 된다.   

## 선점형 OS & 비선점형 OS
* OS를 구분할 때 응답성 기준으로 범용 OS, RTOS를 구분하는 것처럼 프로세스 실행을 다른 프로세스로 넘기는 방식에 따라 선점/비선점 OS로 구분.   

### 비선점 OS
* 현재 실행중인 프로세스보다 우선순위가 높은 프로세스가 등장하여도 실행 대상을 바로 변경하지 않음.   
* 현재 실행중인 프로세스가 명시적으로 CPU를 양보할 때까지, 혹은 I/O작업으로 블로킹 상태일 때까지 기다려야함.   
* 따라서 비선점 OS의 경우 인터렉티브 프로그램 구현시 프로그래머 의존도가 높아짐.   
* 프로그래머가 개발한 프로그램이 계속 CPU를 독차지하지 않도록 해야함.   
* 오늘날 대부분 OS는 키보드, 마우스 등 입력에 민감한데 이러한 시스템을 가르켜 인터렉티브 시스템이라함.   

### 선점 OS
* 현재 실행중인 프로세스보다 높은 우선순위의 프로세스가 등장하면 스케줄러에 의해 실행 순서 조정이 됨. 즉, 우선순위가 높은 프로세스가 실행.   
* 스케줄러가 하는 일이 많아지며, 멀티 프로세스 기반 OS에 적합하며 스케줄러에 의해 실행순서가 조정되니 프로그래머가 신경 쓸 일이 거의 없음.   
* 오늘날 우리가 접하는 모든 OS는 선점형 OS라고 보면되며, RTOS도 선점형 OS이다.   
 
 ## 우선순위 스케줄링 알고리즘
 * Windows에서 채택하고 있는 대표적인 선점형 스케줄링 알고리즘 첫번째.   
 * 우선순위가 9인 프로세스와 2인 플로세스를 동시에 실행시키면 보편적인 운영체제에서 우선순위가 더 낮은 2인 프로세스는 결코 실행 안됨.   
 * 이런 상황을 기아 상태라함.   
 * 우선순위 스케줄링 알고리즘은 우선순위가 높은 프로세스를 먼저 실행하는 알고리즘.   
 * 따라서, 우선순위가 높은 프로세스가 작업을 마쳐야 다음 우선순위 프로세스가 실행.   
 * but, 프로그램이 상당 시간 I/O에 시간을 할애
 * 따라서 우선 순위가 높은 프로세스가 I/O 작업을 할 때, 우선순위가 낮은 프로세스가 실행 기회를 얻기도 함.   
 * 즉, 우선순위가 낮은 프로세스가 기아 상태에 빠지는 일은 드문 일.   
 
 ## 라운드 로빈 스케줄링 알고리즘
 * Windows에서 채택하고 있는 대표적인 선점형 스케줄링 알고리즘 두번쨰.   
 * 우선순위가 동일하다면 누가 먼저 실행?   
 * 정해진 시간 간격만큼만 실행하고 우선순위가 동일한 다른 프로세스에게 cpu할당을 넘김.   
 * 실행의 최소 단위 시간을 퀀텀(Quantum), 혹은 타임 슬라이스라고 함.   
 * 동일한 우선순위의 모든 프로세스들은 이 타임 슬라이스 기분으로 CPU 할당을 받게됨.   
 * 타임 슬라이스가 길 때 : 인터렉티브한 시스템에서 문제가 됨. ex) 마우스의 드래그 앤 드롭 반응이 늦다.   
 * 타임 슬라이스가 짧을 때 : 빈번한 컨텍스트 스위칭 발생, 성능 저하 

## 스케줄링 알고리즘에 의해 스케줄링이 진행되는 경우?
* 스케줄러 동작 시점   
* 라운드 로빈   
-> 매 타임 슬라이스 마다 스케줄러가 동작   

* 우선순위 방식   
-> 새로운 프로세스가 등장하면 스케줄러는 프로세스들의 우선순위를 비교하기 위해 동작   
-> 반대로 현재 실행중인 프로세스가 종료될 때 다른 프로세스를 실행 시키위 위해 스케줄러가 동작    

* 블로킹 상황
-> 현재 실행중인 프로세스가 블로킹 상태가 되면 다른 프로세스가 실행    

## 프로세스의 우선순위가 뒤바뀌는 현상
* 우선순위가 A -> B -> C 순서인 프로세스가 있을 때, 프로세스 A를 실행하다가 C에게 값을 받아와야 한다면, A는 블로킹 상태에 빠지고 C에게 CPU를 넘겨주려 한다.   
* 이 때 B가 우선순위가 높아 먼저 차지하게 되면 A는 그냥 블로킹 상태로 가지말고 C에게 자신의 우선순위를 위임하고 Blocking 상태로 빠진다.   
