# Memory 가시성 & 코드 재배치

* 이슈 : 멀티스레드 환경에서 모든 스레드가 공유 변수를 같은 값으로 읽을까?   
* 메모리 가시성 이슈는 멀티 CPU, 멀티 코어에서 기인한다.   
* Thread가 여러 코어(CPU)에서 동시 실행되는 상황이 메모리 가시성에 영향을 끼친다.  
* 멀티코어(CPU) 환경에서 가시성이 발생하는 이유   
* -> 각각의 코어별로 레지스터와 캐쉬를 가지고 있다.   
* -> 컴파일러 최적화. 컴파일러는 프로그램이 최대한 빨리 실행되도록 레지스터와 캐쉬를 사용한다.   
* 가시성을 유지하려면 한 코어에서 변경한 값을 여러 코어가 공유하는 메인 메모리로 반영해야한다.   
* but, 레지스터>캐시>>>>>>메모리 순으로 속도차이가 있으나 필요한 작업이다.    
* 따라서 필요 시점에만 메인 메모리로 반영하는 것이 필요하다.   
* 그래서 등장하는 개념이 메모리 장벽이다.   
 
## 메모리 장벽(Memory Fence)
* 메모리 장벽을 만나면 그 전까지의 코어의 레지스터나 캐쉬의 변경사항을 메인 메모리에 반영하는 것.   
* 즉, 메인 메모리로 Flush 한다고 한다. 이렇게 해서 다른 코어(CPU)에서 변경된 값을 읽을 수 있도록 하는 것.   
* 메모리 장벽은 값을 변경하는 코어(CPU)뿐만 아니라 값을 읽는 코어(CPU)도 잘 사용해야한다.   
* 메인 메모리에 값을 반영해도 읽어가는 코어(CPU)가 자신의 레지스터나 캐쉬값을 읽는다면 소용 없기 때문   
* 따라서 메모리 장벽을 사용해야하는데 동기화를 위한 Lock을 사용하는 곳에 암시적으로 메모리 장벽이 설치됨.   
* 원리는 Lock이라는 것도 소유하는 코어가 다른 코어들이 Lock을 소유할 수 없다는 것을 판단할 수 있도록 "모든 코어가 공통적으로 같은 값을 읽을 수 있는" 특정 메모리에 표시해 둬야한다.   
* 따라서 Lock에는 메모리 장벽이 필수적으로 들어가야 한다.   
* 메모리 가시성과 메모리 장벽과 관련한 API가 C, C++, Java 같은 언어에 라이브러리 형태로 등장한다.   
* c++의 경우 <atomic> 라이브러리를 활용하면 된다.   
* atomic을 사용해야 하는 제일 중요한 이유는 **가시성 때문이다.**      
* **atomic은 값을 쓰거나 읽는 것을 캐시나 레지스터가 아닌 메인 메모리에서 수행되도록 해준다.**   
* 따라서 임계영역을 블록으로 묶지 않고도 메모리 가시성을 확보 가능하다.   

## 메모리 장벽은 재배치와 관련된다.
* 컴파일러는 메모리 장벽을 넘어서까지 재배치 하지 않는다.   
* 즉, 메모리 장벽이란 이전까지 메모리 작업(레지스터, 캐시 활용)을 메인 메모리로 반영하는 것인데 장벽 이전까지는 프로그래머가 코드에 표현한 순서로 장벽 이전까지이다.   
* 따라서 컴파일러는 메모리 장벽을 넘어서 재배치하지 않는다.   
