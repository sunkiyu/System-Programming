참조 : 뇌를 자극하는 윈도우즈 시스템 프로그래밍   
# Thread 동기화 1

## 스레드 동기화란?
### 여기서 말하는 동기화 => 순서에 있어 질서가 지켜지고 있는가?
## 실행 순서의 동기화
### 스레드의 실행 순서를 정의하고 이 순서에 반드시 따르도록 하는 것이 스레드 동기화
## 메모리 접근에 대한 동기화
### 한 순간에 하나의 스레드만 접근해야 하는 메모리 영역이 존재
* 대표적으로는 데이터 영역과 힙이다.   
* 데이터 영역(전역 변수, 정적 변수 등)에 할당된 변수를 둘 이상의 스레드가 동시 접근할 때 문제 발생     
* 계산 결과가 덮어써지는 문제 발생   
* 즉, 메모리 접근에 있어 동시 접근을 막는 것 또한 스레드 동기화에 해당   
* 즉, 순서의 질서, 메모리 접근에 대한 동기화 모두 스레드의 순서를 중요시하는 것을 말함   
### 차이점?
* 실행순서 동기화 -> 실행, 접근 순서가 이미 정해짐, 그 순서는 반드시 지켜야함.   
* 메모리 접근 동기화 -> 실행 순서가 중요한 상황은 아니고 한 순간 하나의 스레드만 접근하면 되는 상황   
* 즉, 메모리 동시 접근 문제만 발생 안하면 된다.   

## 스레드 동기화에 있어 두 가지 방법
* Windows에는 다양한 동기화 기법을 제공, 크게 두가지   
* 유저 모드 동기화   
=> 동기화 진행시 커널의 힘을 빌리지 않는 동기화 기법(커널 코드 실행 안됨)     
=> 동기화 위해 커널 모드 전환이 불필요해 성능상 이점   
=> 그만큼 기능상 제한도 있음    

* 커널 모드 동기화    
=> 커널에서 제공하는 동기화 기능을 활용하는 방법   
=> 동기화 관련 함수가 호출될 때마다 커널 모드 변경이 필요, 성능 저하로 이어짐    
=> 유저 모드 동기화에서 제공하지 못하는 기능을 제공 받을 수 있다.   
=> 따라서 둘 다 장단점이 있음   
 
 * 임계영역 접근 동기화   
 => 메모리 접근 동기화에 대해 알아보자    
 => 메모리 영역 접근 동기화란 임계 영역의 접근을 동기화 하겠다는 뜻   
 
 * 임계영역?   
 => 전역변수에 둘 이상의 스레드가 동시 접근해 연산 실행시 문제 발생할 수 있음   
 => 이러한 문제를 일으키는 코드 블록을 임계 영역(Critical Section)이라 함.   
 => 즉, 문제의 원인이 되는 코드 블록을 가르켜 임계영역이라함   
 => 전역변수에 할당된 메모리 공간 != 임계영역이다.(같지 않다)   
 => 임계 영역은 상황에 따라 한 줄일 수도, 여러 줄이 묶여서 임계영역을 구성하기도 함   
 => 즉, 임계영역이란 배타적 접근(한 순간에 하나의 스레드만 접근)이 요구되는 공유 리소스(전역변수와 같은)에 접근하는 코드 블록을 의미     
 
 ## 해결책
* 임계영역에 대한 문제의 해결책은 임계영역의 동시 접근을 막는 것   
* 즉, 동기화 기법을 통해 임계 영역은 한 순간에 하나의 스레드만 실행될 수 있도록 제한   

## 동기화 기법의 종류
### 유저모드 동기화
1. 크리티컬 섹션 동기화 (유저 모드 동기화)   
=> 메모리 접근 동기화에 사용   
2. 인터락 함수 동기화(유저 모드 동기화)   
=> 메모리 접근 동기화에 사용   

### 커널모드 동기화
1. 뮤텍스 동기화(커널 모드 동기화)     
=> 메모리 접근 동기화에 사용   
2. 세마포어 동기화(커널 모드 동기화)   
=> 메모리 접근 동기화에 사용   
3. 이름 있는 뮤텍스 기반의 동기화(커널 모드 동기화)   
=> 프로세스간 동기화에 사용   
4. 이벤트 기반 동기화(커널 모드 동기화)    
=> 실행 순서 동기화에 사용   
=> 특별히 용도가 정해진 것은 아니고 목적에 적합한 동기화 기법을 사용하면 간결하고 정확한 코드가 나옴   
=> 이벤트는 실행순서 동기화에 사용하는 것이 적절   
=> 사실 그런 목적으로 디자인된 기법

### 유저 모드 동기화
* 유저 모드 동기화는 커널 모드로의 전환이 불필요하여 성능상 이점 얻는다.   
* 커널 모드 동기화에 비해 활용 방법도 단순하다.   

### 크리티컬 섹션 기반 동기화
=> 화장실에 들어가기 전 열쇠로 문을 열고 들어가고, 나와서는 다른 사람을 위해 화장실 앞에 열쇠를 걸얻둔다.   
=> 이것이 크리티컬 섹션 동기화 방식   
* 핵심은 열쇠를 얻은 자(스레드 등)만이 화장실에 들어갈 수 있다는 것   
* 크리티컬 섹션 기반의 동기화를 사용하려면?   
* 크리티컬 섹션 오브젝트를 만들고 초기화    
* __EnterCriticalSection__ 임계영역 진입을 위한 함수, 누군가(다른 스레드)에 의해 이미 호출된 상태라면 블로킹됨. 그리고 열쇠가 반환되면 블로킹 상태에 있던 함수가 빠져나온다.   
* __LeaveCriticalSection__ 임계영역을 빠져나오고 호출하는 함수. 화장실에 열쇠를 다시 걸어놓는 행위 만약 EnterCriticalSection을 호출한 뒤 블로킹 상태의 스레드가 있다면    
* 이 함수 호출로 블로킹 상태에서 빠져나와 임계영역으로 진입. 이 함수 호출이 완료된것을 호출 스레드가 크리티컬 섹션 오브젝트를 반환했다고 표현   

### 인터락 함수 기반 동기화
* 위의 동기화 방식이 하나의 변수에 대한 접근 방식을 동기화 하는 것이 목적이라면 이 용도로 특화된 인터락 함수를 사용하는 것도 나쁘지 않다.   
* 인터락 함수는 내부적으로 한 순간에 하나의 스레드에 의해서만 실행되도록 동기화 되어있다.   
* 대표적인 인터락 함수 두가지   
* InterlockedIncrement 값을 하나 증가 시킬 32비트 변수의 주소값을 전달. 둘 이상의 스레드가 공유하는 메모리에 저장된 값을 이 함수를 통해 증가시킬 경우   
* 동기화 상태에서 접근하는 것과 동일한 안정성을 보장   
* InterlockedDecrement 값을 하나 감소 시킬 32비트 변수의 주소값을 인자로 전달. 동시에 둘 이상의 스레드 접근에 의한 문제는 발생하지 않는다.   
* 위에서 소개한 크리티컬 섹션 동기화 기법도 내부적으로는 인터락 함수 기반으로 구현됨    
* 인터락 함수는 유저모드 기반이기 때문에 속도가 빠르다.   
* MS에서는 다양한 인터락 함수를 제공   

### Volatile 키워드
* 최적화를 수행하지 마라   
=> 컴파일러는 프로그래머가 프로그래밍 해놓은 코드를 컴파일 하는 과정에서 코드 최적화를 수행   
=> 이런 최적화 문제가 되는 상황에서 사용하는 것이 volatile 키워드이다.   
* 메모리에 직접 연산하라   
* volatile 키워드로 선언하면 해당 데이터는 절대로 캐쉬되지 않음   
* 해당 포인터가 가르키는 메모리 공간으로 전송되는 데이터는 절대로 캐쉬 되지 않는다.   
* 따라서 어떤 포인터에 값을 입력하면 캐쉬 메모리가 아닌 메모리에 저장됨.    

### 커널 모드 동기화
* 우리는 한 순간 하나의 스레드에 의해 실행되어야하는 임계영역 동기화 방법에 대해 이야기하고 있다.   
* 커널 모드 동기화는 유저모드 동기화에 비하면 느리다.   
* 유저 모드 -> 커널 모드, 커널 모드 -> 유저 모드로 전환이 필요하기 때문   
* Windows 커널 레벨에서 제공해주는 동기화 기법이기 때문에 유저모드 동기화에서 제공해주지 못하는 기능을 제공받을 수 있다.   
* 뮤텍스와 세마포어에 대해 알아보자   

### 뮤텍스 기반 동기화
* 뮤텍스 기반 동기화 기법의 경우는 화장실 열쇠에 비유할 수 있는 것이 뮤텍스 오브젝트(그냥 뮤텍스라도 함)이다.   
* CreateMutex 함수      
* IpMutexAttributes 뮤텍스도 커널 오브젝트이므로 보안 속성 지정 가능   
* bInitialOwner 뮤텍스는 뮤텍스 오브젝트를 생성하는 스레드에게 먼저 임계영역에 접근할 권한을 부여할 수 있다.   
* IpName 뮤텍스의 이름을 붙이기 위해 사용. 이름을 주었을 때 생성되는 뮤텍스를 이름있는 뮤텍스라고 표현    
* 반환 타입이 HANDLE인데 이것은 뮤텍스 가 커널 오브젝트임을 말하는 것   
* 뮤텍스가 커널 오브젝트인 점만 봐도 뮤텍스는 커널 레벨 동기화 기법임   
* 이렇게 생성되는 뮤텍스는 크리티컬 섹션 오브젝트와 달리 최적화 함수 호출 필요 없음     
* 커널 오브젝트는 signaled, non-signaled 상태를 지님   
* 보통 커널 오브젝트는 non-signaled 상태에 있다가 특정 상황이 되면 signaled 상태가 된다.   
* 스레드나 프로세스의 정보를 담고 있는 커널 오브젝트는 해당 스레드나 프로세스가 종료되었을 시 signaled 상태가 됨   
* 뮤텍스는 signaled가 언제될까?   
* 열쇠에 비유하면 누군가 열쇠를 취했을 때 non-signaled가 된고 취득한 열쇠를 반환했을 때 signaled 상태가 된다.   
* 즉, 뮤텍스는 누군가에 의해 획득이 가능할 때 signaled 상태에 놓인다.   
* 따라서 waitforsingleobject 함수를 임계영역 진입을 위한 뮤텍스 획득 용도로 사용 가능   
* 뮤텍스 반환시엔 다음 함수를 이용해서 반환, 물론 뮤텍스는 다시 signaled 상태가 됨   
* ReleaseMutex   
* WaitForSingleObject는 인자로 전달된 핸들의 커널 오브젝트가 signaled 상태가 되어 반환한 경우 non-signaled 상태로 변경한다.   

### 뮤텍스 기반 임계 영역 보호 원리
* 스레드는 임계영역에 들어가기 앞어 뮤텍스를 획득해야함    
* 따라서 뮤텍스 핸들을 인자로 전달하며 WaitforSingleobject를 호출    
* 만약 뮤텍스 획득이 가능하면 signaled 상태에 있고 때문에 뮤텍스를 획득하며 임계 영역 진입   
* WaitForSingleObject 함수는 커널 오브젝트가 signaled 상태가 되어 반환할 경우 해당 커널 오브젝트를 non-signaled 상태로 변경하므로   
* 다른 스레드들은 임계 영역으로 진입이 제한됨   
* 임계 영역에서 일을 마친 스레드가 임계 영역을 빠져나오며 ReleaseMutex 함수르 호출하면 signaled 상태가 되어 다른 스레드의 진입을 허용한다.   

### 세마포어(Semaphore) 기반의 동기화
* 세마포어는 뮤텍스와 유사   
* OS로 유명한 교수의 말을 빌리면 세마포어 중 단순화된 세마포어(바이너리 세마포어)를 가르켜 뮤텍스라 한다.라고 언급했다.   
* 엄밀히 말하면 뮤텍스는 세마포어의 일종이다. 라고 표현해야 옳다.   
* 뮤텍스와 세마포어가 공존하는 것을 보면 차이가 있는 것인데 뭘까?   
* 바로 Count 기능이다.   
* 세마포어는 카운트 기능이 존재하지만 뮤텍스에는 존재하지 않는다.    
* 뮤텍스는 임계영역에 접근 가능한 스레드 개수를 조절하는 기능이 없지만 세마포어는 있다.    
* 즉, 임계 영역의 접근 허용 스레드 개수를 하나로 제한하기 위해 사용되는 세마포어를 가르켜 바이너리 세마포어라하는데 뮤텍스와 동일한 기능을 제공한다.   
* 세마포어를 생성하는 함수 CreateSemaphore   
* IpSemaphoreAttributes 보안 속성을 지정하기 위한 매개 변수   
* lInitialCount 세마포어에서 가장 중요한 전달인자. 세마포어는 값을 지니는데 이 값을 기반으로 임계 영역에 접근 가능한 스레드 개수를 제한함   
* 전달 인자 값이 10이라면 총 10 갱의 스레드가 임계영역에 접근 가능하다는 사실    
* lMaximumCount 세마포어가 지닐 수 있는 값의 최대 크기. 이 값이 1이 될 경우 뮤텍스와 동길 기능하는 바이너리 세마포어   
* 기본적으로 2번째 전달 인자 값보다 커야한다.   
* lpName 세마포어 이름을 붙이기 위해 사용 

## 세마포어 2번째 전달 인자에 의해 초기 카운트가 결정
* 카운트가 0일 경우 non-signaled 상태에 놓이게 되며, 1 이상인 경우 signaled 상태에 있게 된다.   
* waitforsingleobject 함수에 세마포에 핸들을 인자로 전달하며 호출하면 그 값이 하나씩 감소하면서 반환한다.   
* 따라서 세마포어를 생성할 때 초기 카운트를 10으로 설정하면 waitforsingleobject 함수가 열번 호출될 때까지 카운트가 하나씩 감소하며 함수를 반환한다.   
* 그리고 11번째 호출 시 세마포어 카운트가 0인 관계로 블로킹 상태가 된다.   

## 세마포어 기반 카운트 및 임계 영역 보호 원리
* ReleaseSemaphore 함수로 카운트 값을 증가 시킨다.   

### 이름 있는 뮤텍스(named mutex) 기반의 프로세스 동기화
* 뮤텍스 오브젝트, 세마포어 오브젝트의 생성함수를 자세히 보면 이름을 붙여줄 수 있다.   
* 뮤텍스가 이름이 있으면 이름있는 뮤텍스라한다.    
* 세마포어에 이름이 있으면 이름있는 세마포어라 한다.     
* 이름있는 동기화 오브젝트는 어떤 용도로 사용할까?    

### 이름있는 뮤텍스
* 뮤텍스는 프로세스가 아니라 커널, 즉 운영체제의 소유   
* 따라서 서로 다른 프로세스 영역에 존재하는 스레드가 뮤켁스를 이용해서 동기화 하는 상황이 가능하다.    
* 뮤텍스는 커널 오브젝트이므로 어떤 프로세스의 요청에 의해 만들어졌다 하더라도 그 프로세스의 영역에 존재하는 것이 아니다.   
* 즉, 커널이 관리(생성 및 소멸의 시기를 정함)하는 오브젝트이므로 다른 프로세스의 접근 가능   
* 핸들 유효성 문제가 있다.    
* 핸들 테이블은 커널 오브젝트와 이를 지칭하는 핸들 값에 대한 정보를 담고 있는 테이블인데 프로세스별로 독립적임    

### 이름있는 뮤텍스가 필요한 이유
* 프로세스 A가 뮤텍스를 생성했다면 프로세스 B는 프로세스 A가 생성한 뮤텍스에 접근 불가능하다. (핸들 테이블을 공유 안하므로)    
* 왜냐하면 프로세스 A를 통해 만들어진 커널 오브젝트인 관계로 프로세스 B의 핸들 테이블에는 이에 대한 정보 없음   
* 이 문제를 해결하기 위해 이름있는 뮤텍스가 나왔다 이 이름은 윈도우즈 운영체제 내에서 유일한 이름   
* 따라서 이 이름을 통해 windows가 관리하고 있는 커널 오브젝트에 접근 가능한 핸들 정보를 얻을 수 있다.   
* OpenMutex 얻고자하는 핸들 정보의 커널 오브젝트 이름을 전달, 여기로 전달하는 이름과 일치하는 이름을 지니는 뮤텍스가 존재하면 뮤텍스의 핸들이 반환    
* 물론 핸들 테이블에 이해 대한 정보도 추가된다.   

### 뮤텍스의 소유와 Wait_abandoned
* waitforsingleobject 함수 반환값 중 wait_abandoned라는 것이 있다.   
* 이 반환값의 의미는?    
* A와 B 스레드가 있고 세마포어 오브젝트 C가 있다    
* A 스레드가 세마포어 C의 카운트를 하나 감소시켰다 그렇다면 카운트를 증가시키는 것 역시 스레드 A가 해야한다.    
* 일반적인 멀티 스레드 동기화 구조이다.   
* 그러나 이러한 제약사항을 반드시 지켜줘야하는 것은 뮤텍스 하나이다. 즉, 세마포어의 경우 세마포어를 획득하는 스레드와 반환하는 스레드가 달라도 문제되지 않는다.   
* 그렇다면 세마포어는 소유의 개념이 아닐까?   
* 뮤텍스는 획득한 스레드가 직접 반환하는 것이 원칙, 본인만 반환 가능이다.   
* 세마포어와 이외의 동기화 오브젝트는 다른 스레드가 반환해줘도 된다.
* 그렇다면 Wait_abandoned 가 반환되는 상황은?    
* 두개의 스레드 A,B와 동기화 오브젝트 뮤텍스 C가 있을 경우 스레드 A가 뮤텍스 C를 획득했다.   
* 이 때 스레드 A가 뮤텍스를 반환하지 않고 종료되었을 경우 windows는 이러한 상황을 파악한다.   
* Windows는 스레드와 뮤텍스의 상태를 예의 주시하여 이런 문제를 인식하고 더 이상 정상적인 방법으로 반환이 불가능한 뮤텍스를 대신 반환해준다.   
* 다음 대기자인 스레드 B가 뮤텍스를 소유할 수 있도록 도와준다.   
* 스레드 B는 wait_abandone 값을 반환받게 된다.   
* 이 값은 디버깅에 삽입하는 경우가 대부분이다.    
