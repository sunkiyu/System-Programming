참조 : 뇌를 자극하는 윈도우즈 시스템 프로그래밍
# Thread 동기화 2
## 실행 순서에 있어서의 동기화
* 스레드의 실행 순서를 동기화 한다는 것?   
* 메모리에 접근하는 스레드의 실행 순서를 동기화     
* 즉, 실행순서 동기화는 메모리 접근 동기화를 포함하는 개념   
* 다만, 포커스가 실행순서에 맞춰져 있기 때문에 실행 순서 동기화라는 표현을 사용   

## 생산자/소비자 모델
* 실행순서 동기화를 생산자/소비자 모델이라 불리는 스레드 모델을 통해 설명   
* 중요한 것은 순서. 생산자가 물건을 생산해야 소비자가 구매가능   
* 이 순서가 뒤바뀜녀 소비자는 없는 물건을 찾게 되고 소비자가 떠난 뒤에 물건을 생산. 소비되지 않은 채로   
* 스레드의 순서가 중요한 상황을 소개할 때 소개되는 모델. 생산자와 소비자는 스레드를 의미   
* 생산자는 문자열을 생성 -> 소비자는 생산된 문자열을 소비   
* 생성량이 많아 소비가 속도를 따라가지 못하면 문제가 발생    
* 이러한 문제점을 해결하기 위해 두 개의 스레드를 활용하여 하나는 입력, 다른 하나는 출력을 담당   
* 그리고 그 사이에 메모리 버퍼를 두어 두 개의 스레드가 입력 및 출력 속도에 상관 없이 독립적으로 실행되도록 함    

## 이벤트(Event) 기반 동기화
* 윈도우 개발자들은 스레드의 실행 순서 동기화 한다고 하면 가장 먼저 떠올리는 것이 이벤트 기반 동기화 기법이다.    
* 세마포어나 뮤텍스와 같이 이 기법에도 동기화를 위한 오브젝트가 사용된다.   
* 여기서 사용되는 오브젝트는 이벤트 오브젝트라 부른다.   
* 이벤트는 열쇠 대신 상태의 개념을 도입하여 설명한다.   
* 생산자가 물건을 생산한 상태가 되면 이를 감지한 소비자는 물건을 소비한다.   
* 즉 상태에 따라 실행되어야 할 스레드가 결정된다.   
* CreateEvent   
* bManualReset  수동 리셋모드/자동 리셋모드 중 어느것으로 이벤트 오브젝트를 생성하는지 결정 true 수동리셋 false 자동리셋    
* bInitialState 이벤트 오브젝트의 초기 상태를 결정 true signaled 상태, false non-signaled 상태 이벤트 생성   
* lpName 이벤트 오브젝트의 이름을 결정   

## Singnaled 상태 (신호 받은 상태 ) / Non-Signaled 상태 (신호 받지 못한 상태)
* 스레드나 프로세스의 커널 오브젝트의 경우 초기에는 non-signaled 상태로 생성되고 프로세스나 스레드가 종료될 경우 해당 커널 오브젝트는 signaled 상태로 


쓰레드나 프로세스의 커널 오브젝트의 경우 - 초기에는 Non-Signaled 상태로 생성되고, 쓰레드나 프로세스가 종료될 경우 해당 커널 오브젝트는 Signaled 상태로 "자동 변경" 된다.
그러나 이벤트 오브젝트는, 자동으로 Signaled 상태가 되지 않는다. 
자동으로 Signaled 상태가 되는 특정 상황이라는 것이 존재하지 않는다.
함수 호출을 통해 직접 이벤트 오브젝트의 상태를 Signaled로 바꿔야 한다.
Non-Signaled 상태의 이벤트 오브젝트 핸들을 인자로 전달하면서 WaitForSingleObject 함수를 호출한 쓰레드는 블로킹 상태가 된다. 
그러나 Signaled 상태가 되어 블로킹 상태에 있던 쓰레드가 빠져 나온다면, 빠져 나온 이후 (WaitForSingleObject 함수 호출 완료 이후 ) 이벤트 오브젝트는 어떠한 상태에 놓이겠는가?
Signaled 상태 그대로일까? Non-Signaled 상태로 변경되었을까?
Signaled 상태 그대로라면 - 수동 리셋 모드(Manual-Reset Mode) 이벤트 오브젝트라는 의미
Non-Signaled 상태로 자동 변경되었다면 - 자동 리셋 모드(Auto-Reset Mode) 이벤트 오브젝트라는 의미
앞서 소개한 CreateEvent 함수의 두번째 전달인자가 위와 같은 의미였다. 
 

즉, 아래와 같은 특성을 이용해서 쓰레드의 실행순서를 동기화 하게 된다.
1. 이벤트 커널 오브젝트는 프로그래머의 요청에 의해서 Signaled 상태가 된다. 
2. Non-Signaled 상태의 이벤트 오브젝트 때문에 WaitForSignaledObject 함수 호출이 블로킹 되었다면, Signaled 상태가 되는 순간 블로킹된 함수를 빠져 나오게 된다. 그리고 이때 자동 리셋 모드 이벤트 오브젝트라면, Non-Signaled 상태로의 변경은 자동으로 이뤄진다.

이벤트 오브젝트의 특성
그림의 윗부분은 수동 리셋 모드 이벤트이기 때문에 Signaled 상태에서 Non-Signaled 상태로의 변경을 위해 ResetEvent 함수를 호출해야 함을 설명한다.
그림의 아래부분은 자동 리셋 모드의 이벤트이기 때문에 WaitForSingleObject 함수 호출이 필요없다는 뜻이다. 
블로킹된 WaitForSingleObject 함수 호출을 빠져 나올 경우 자동으로 Non-Signaled 상태로 변경되지 않으므로, 수동으로 (ResetEvent 함수를 호출해서) 변경해줘야 함을 설명하는 것이다. 
BOOL ResetEvent ( 1 ) 
1. HANDLE hEvent : 이벤트 오브젝트의 핸들을 인자로 전달한다. 전달된 핸들의 오브젝트는 Non-Signaled 상태가 된다.
BOOL SetEvent ( 1 ) 
1. HANDLE hEvent : 이벤트 오브젝트의 핸들을 인자로 전달한다. 전달된 핸들의 오브젝트는 Signaled 상태가 된다. 
 

 

수동 리셋(Manual-Reset) 모드 이벤트(Event)의 활용 예
수동 리셋 모드 이벤트는 둘 이상의 쓰레드를 동시에 깨워서 실행해야 할 때 아주 좋은 도구가 될 수 있다. 
 

 

이벤트(Event) + 뮤텍스(Mutex)
이벤트 오브젝트로는 생산자/소비자 모델을 구현하였고, 이 과정에서 소비자(소비자 쓰레드)가 둘 이상인 관계로 이 둘 사이에서의 동기화를 위해서 뮤텍스를 적용할 수 있다.
이벤트와 뮤텍스를 동시에 사용해서 동기화해야 하는 상황은 실무 개발환경에서 자주 접하는 상황이다.
 

타이머(Timer) 기반 동기화 
Windows에서는 Signaled 상태라는 개념이 중요하다.
어떤 커널 오브젝트는 특정 상태가 되면 Signaled 상태가 되고, 또 어떤 커널 오브젝트는 명시적인 함수 호출을 통해 Signaled 상태가 된다. 
이번에 소개하는 동기화 오브젝트는 정해진 시간이 지나면 자동으로 Signaled 상태가 되는 특성을 지닌다. 
따라서 이름도 타이머(정확히 표현하면 Waitable Timer)이다.
타이머를 기반으로 쓰레드를 동기화 한다는 것은 임계영역 문제 해결을 위한 동기화와는 관점이 다르다.
여기서 말하는 동기화는, 쓰레드의 실행시간 및 실행주기를 결정하겠다는 의미이다. 
따라서 타이머를 쓰레드 동기화 부분에서 다루기 애매한 부분이 있다. 
여기서는 개념을 다루고, 사용 예와 장점 특징은 19장에서 다룬다.
타이머 기반 동기화는 두 가지 형태로 구분 지을 수 있다.
수동 리셋 타이머 : 가장 일반적인 타이머로서, 알람(Alarm)시계를 생각하자. 새벽 6시에 알람을 맞춰두면 새벽 6시에 시계가 울린다. 이런 특성의 타이머다.
주기적 타이머 : 수동 리셋 타이머에 주기적인 특성이 가해진 형태로 이해하면 된다. 요즘 알람시계는 새벽 6시에 알람을 맞추면 , 6시 이외에도 30분마다 주기적으로 알람이 울리도록 설정할 수 있다. 이런 특성의 타이머다.
 

수동 리셋 타이머 (Manual-Reset Timer)
타이머 오브젝트는 정해진 시간이 지나야 Signaled 상태가 되는 커널 오브젝트이다. 
HANDLE CreateWaitableTimer ( 1, 2, 3 )
1. LPSECURITY_ATTRIBUTES IpTimerAttributes : 보안 속성을 지정하는데 사용. 핸들을 자식 프로세스에게 상속하고자 할 경우 NULL이 아닌 다른 값을 전달
2. BOOL bManualReset : 타이머 오브젝트를 수동 리셋(Manual-Reset) 모드로 생성할 것인지, 자동 리셋(Auto-Reset) 모드로 생성할 것인지 결정. 앞서 이벤트 오브젝트를 통해 이해한 개념을 적용해도 된다.
3. LPCTSTR IpTimerName : 타이머 오브젝트에 이름을 붙여줄 경우 사용되는 전달인자. NULL-이름없는 타이머 오브젝트 생성
CreateEvent와 의미가 동일하지만, 매개변수의 개수가 하나 적다. 바로 "커널 오브젝트 생성 시 어떤 상태로 둘 것인지, Signaled상태 or Non-Signaled 상태" 를 결정하는 요소이다.
이 매개변수가 빠진 이유는 타이머 오브젝트의 특성 때문이다.
타이머는 시간이 지나서 Signaled 상태가 되어야 의미가 있다.
즉, 타이머 오브젝트가 생성되자마자 Signaled 상태가 된다면 아무 의미도 없다. 
따라서 타이머 오브젝트는 무조건 Non-Signaled 상태로 생성된다. 
BOOL SetWaitableTimer ( 1, 2, 3, 4, 5, 6 )
1. HANDLE hTimer : 알람을 설정할 타이머 오브젝트의 핸들을 인자로 전달한다. 정해진 시간이 되면 인자로 전달된 핸들의 커널 오브젝는 Signaled 상태가 된다.
2. const LARGE_INTEGER* pDueTime : 알람이 울리는 시간, 즉 커널 오브젝트가 Signaled 상태가 되는 시간을 지정하기 위한 매개변수. + 값이라면 절대시간, - 값이라면 상대시간을 의미한다.
즉, 0시 0분이라고 시간을 지정하고 싶은 경우 + 값을, 지금으로부터 0초 후에 울려달라 요청할 경우 - 값을 전달한다.
1000만붙의 1초 (100 Nanoseconds) 단위로 시간을 설정한다.
3. LONG IpERIOD : 타이머가 주기적으로 알람을 울리게 할 때 사용하는 전달인자다. 주기가 되는 시간 간격을 1/1000초 (Milliseconds) 단위로 전달하면 된다. 0 전달 시 주기적인 알람을 사용하지 않겠다는 의미
4. PTIMERAPCROUTINE pfnCompletionRoutine : 19장에서 소개 
5. LPVOID IpArgToCompletionRoutine : 19장에서 소개
6. BOOL fResume : 전원관리와 관련있는 매개변수. 기본적으로 FALSE 전달은 원칙으로 하자.
 

주기적 타이머 (Periodic-Timer)
일정시간 간격으로 알람일 울리는 타이머를 의미한다.
중간에 타이머를 해제하고자 하는 경우 아래 함수를 사용하면 된다.
주의할 것은 CancelWaitableTimer 함수는 가동중에 있는 타이머를 중지시키는 기능의 함수이지, 타이머를 소멸시키거나 할당된 자원을 반환하는 함수가 아니다. 
반환하고 소멸시키고 싶을 경우, 여느 커널 오브젝트와 마찬가지로 CloseHandle 함수를 호출하면 된다.
BOOL CancelWaitableTimer ( 1 )
1. HANDLE hTimer : 알람을 해제할 타이머의 핸들을 전달한다. 전달된 핸들의 타이머 오브젝트는 알람이 해제된다. (Inactive 상태가 된다)


출처: https://popcorntree.tistory.com/66 [어떤 프로그래머]
