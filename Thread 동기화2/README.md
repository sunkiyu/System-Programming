참조 : 뇌를 자극하는 윈도우즈 시스템 프로그래밍
# Thread 동기화 2
## 실행 순서에 있어서의 동기화
* 스레드의 실행 순서를 동기화 한다는 것?   
* 메모리에 접근하는 스레드의 실행 순서를 동기화     
* 즉, 실행순서 동기화는 메모리 접근 동기화를 포함하는 개념   
* 다만, 포커스가 실행순서에 맞춰져 있기 때문에 실행 순서 동기화라는 표현을 사용   

## 생산자/소비자 모델
* 실행순서 동기화를 생산자/소비자 모델이라 불리는 스레드 모델을 통해 설명   
* 중요한 것은 순서. 생산자가 물건을 생산해야 소비자가 구매가능   
* 이 순서가 뒤바뀜녀 소비자는 없는 물건을 찾게 되고 소비자가 떠난 뒤에 물건을 생산. 소비되지 않은 채로   
* 스레드의 순서가 중요한 상황을 소개할 때 소개되는 모델. 생산자와 소비자는 스레드를 의미   
* 생산자는 문자열을 생성 -> 소비자는 생산된 문자열을 소비   
* 생성량이 많아 소비가 속도를 따라가지 못하면 문제가 발생    
* 이러한 문제점을 해결하기 위해 두 개의 스레드를 활용하여 하나는 입력, 다른 하나는 출력을 담당   
* 그리고 그 사이에 메모리 버퍼를 두어 두 개의 스레드가 입력 및 출력 속도에 상관 없이 독립적으로 실행되도록 함    

## 이벤트(Event) 기반 동기화
* 윈도우 개발자들은 스레드의 실행 순서 동기화 한다고 하면 가장 먼저 떠올리는 것이 이벤트 기반 동기화 기법이다.    
* 세마포어나 뮤텍스와 같이 이 기법에도 동기화를 위한 오브젝트가 사용된다.   
* 여기서 사용되는 오브젝트는 이벤트 오브젝트라 부른다.   
* 이벤트는 열쇠 대신 상태의 개념을 도입하여 설명한다.   
* 생산자가 물건을 생산한 상태가 되면 이를 감지한 소비자는 물건을 소비한다.   
* 즉 상태에 따라 실행되어야 할 스레드가 결정된다.   
* CreateEvent   
* bManualReset  수동 리셋모드/자동 리셋모드 중 어느것으로 이벤트 오브젝트를 생성하는지 결정 true 수동리셋 false 자동리셋    
* bInitialState 이벤트 오브젝트의 초기 상태를 결정 true signaled 상태, false non-signaled 상태 이벤트 생성   
* lpName 이벤트 오브젝트의 이름을 결정   

## Singnaled 상태 (신호 받은 상태 ) / Non-Signaled 상태 (신호 받지 못한 상태)
* 스레드나 프로세스의 커널 오브젝트의 경우 초기에는 non-signaled 상태로 생성되고 프로세스나 스레드가 종료될 경우 해당 커널 오브젝트는 signaled 상태로 "자동 변경" 된다.   
* 그러나 이벤트 오브젝트는 자동으로 Signaled 상태가 되지 않아 함수 호출을 통해 직접 이벤트 오브젝트 상태를 Signaled로 바꿔야함   
* non-Signaled 상태의 이벤트 오브젝트 핸들을 인자로 전달하며 WaitForSingleobject 함수를 호출한 스레드는 블로킹 상태가 됨   
* signaled 상태가 되어 블로킹 상태에서 빠져나오면 이벤트 오브젝트의 상태는?   
* signaled 상태 -> 수동 리셋 모드   
* non-signaled 상태 -> 자동 리셋 모드   
* CreateEvent 함수의 두번째 전달 인자가 위와 같은 의미이다.    
 
### 아래와 같은 특성을 이용해 스레드 실행순서를 동기화 해야한다.   
* 이벤트 커널 오브젝트는 프로그래머의 요청에 의해 signaled 상태가 된다.    
* non-signaled 상태의 이벤트 오브젝트 때문에 waitforsingleobject가 블로킹 되었다면, signaled 상태가 되는 순간 블로킹을 빠져나오고 이 때 자동 리셋 오브젝트라면    
* non-signaled 상태로 자동 변경된다.   

### 이벤트 오브젝트의 특성
* 수동 리셋 모드 이벤트는 signaled에서 non-signaled 상태로 변경을 위해 ResetEvent 함수를 호출해야한다.   
* 블로킹된 waitforsingleobject 함수 호출을 빠져 나올 경우 자동으로 non-signaled 상태로 변경되지 않으므로 수동으로 ResetEvent 변경 해줘야 한다.   
 
### 수동 리셋 모드 이벤트의 활용 예
* 수동 리셋 모드 이벤트는 둘 이상의 스레드를 동시에 깨워서 실행해야 할 때 유용하다.   

### 이벤트 + 뮤텍스
* 이벤트 오브젝트로는 생산자/소비자 모델을 구현하고 이 과정에서 소비자(스레드)가 둘 이상인 관계로 이 둘 사이에서의 동기화를 위해 뮤텍스를 적용가능.   
* 이벤트와 뮤텍스를 동시에 사용해서 동기화 하는 경우는 실무 개발 환경에서 자주 접하는 상황이다.   

## 타이머(Timer) 기반 동기화 
* 윈도우에서는 signaled 상태라는 개념이 중요.   
* 어떤 커널 오브젝트가 특정 상태가 되면 signaled 되고, 어떤 커널 오브젝트는 명시적 함수 호출을 통해 signaled 상태가 됨.   
* 타이버 기반 동기화 오브젝트는 정해진 시간이 지나면 자동으로 signaled 상태가 되는 특성을 지님   
* 따라서 이름도 타이머(waitable timer)이다.   
* 타이머를 기반으로 스레드 동기화 한다는 것은 임계영역 문제 해결을 위한 동기화와는 다른 관점임   
* 타이머 기반 동기화는 스레드의 실행시간 및 실행 주기를 결정   
* 타이머 기반 동기화는 두가지 형태   
* 수동 리셋 타이머 : 일반적인 타이머, 알람시계, 시간을 맞춰두면 그때 울린다는 특성   
* 주기적 타이머 : 수동 리셋 타이머에 주기적 속성이 가해짐. 주기적으로 울림   

### 타이머는 시간이 지나서 Signaled 상태가 되어야 의미가 있음
* 타이머 오브젝트가 생성되자마자 Signaled 상태가 된다면 아무 의미가 없다.    
* 따라서 타이머 오브젝트는 무조건 Non-Signaled 상태로 생성

### 주기적 타이머 (Periodic-Timer)
* 일정시간 간격으로 알람일 울리는 타이머를 의미한다.   
* 중간에 타이머를 해제 가능 CancelWaitableTimer     
