# Memory Fragmentation 메모리 단편화   
* RAM의 메모리 공간이 작은 조각으로 나뉘어 사용 가능한 메모리가 있지만 메모리 할당이 불가능한 상태를 보고 메모리 단편화가 발생했다고 한다.   

## 내부 단편화 (Internal Fragmentation)
* 메모리를 할당할 경우 프로세스가 실제로 필요(사용)하는 양보다 더 큰 메모리가 할당되어 메모리 공간이 낭비되는 상황   
=> Ex) Notepad.exe를 실행할 경우 OS가 4kb를 할당해줌, But 실제 사용량은 1kb이고 필요 이상으로 프로세스가 메모리를 할당받아 내부 단편화가 3kb만큼 생김   

## 외부 단편화 (External Fragmentation)
* 메모리가 할당-> 해제되는 작업이 반복될수록 중간중간 작은 메모리(Memory Gap)이 발생한다.   
* 이처럼 중간중간 생기는 MemoryGap이 늘어날수록 할당받지 않은 메모리 공간은 충분하지만 실제로 할당할 수 없는 상황을 보고 외부단편화가 발생했다고 한다.   
* Ex) 메모리에 8mb짜리 프로세스가 할당되고 24mb짜리 프로세스가 할당되었을 경우 8mb 프로세스를 종료시키면 8mb만큼 빈 공간(Memory Gap)이 발생한다.   
* 이와 같은 케이스가 반복되면 빈 메모리가 계속 쌓이는데 빈 메모리가 충분하여 프로세스를 할당할 공간은 있지만 마땅한 공간이 없을 경우 외부단편화가 발생했다고 한다.   
* 빈 메모리의 공간중에 제일 큰 빈 메모리가 8mb라고 한다면 9mb짜리 프로세스를 할당을 해야할 때 마땅한 공간은 없지만 전체적으로 메모리 여유는 있을 때   

## 메모리 단편화 문제 해결 솔루션

### 페이징 기법 - 가상메모리 사용, 외부 단편화 해결, 내부 단편화 존재
* 보조기억장치(HDD, SSD ...등)를 활용하는 것으로 가상메모리를 같은 크기의 블록으로 나눈것을 페이지(일반적으로 약4kb)라고하며 RAM을 페이지와 같은 크기로 나눈것을 프레임이라 한다.   
* 즉, 가상메모리 블록 -> 페이지, 물리메모리 블록-> 프레임   
* 페이징이란 사용하지 않는 프레임을 페이지에 옮기고 필요한 메모리를 페이지 단위로 프레임에 옮기는 것을 말한다.   
* 페이지와 프레임을 대응시키기 위해 페이지 맵핑과정이 필요하여 페이징 테이블을 만든다. MMU(Memory Management Unit)이 이를 도와준다.   
* 페이징 기법을 사용하면 연속적이지 않은 공간도 활용할 수 있기 때문에 외부 단편화 문제를 해결 가능하나, 프로세스가 페이지 단위(4kb)를 꽉채워 사용하는게 아니므로 내부 단편화 문제는 존재한다.   
* 페이지 단위를 작게하면 내부 단편화 문제도 해결 가능할 수 있지만 페이지 맵핑과정이 많아지므로 오히려 효율이 떨어질 가능성이 있다.   

### 세그멘테이션 기법 - 가상메모리사용, 내부 단편화 해결, 외부 단편화 존재
* 페이징에서는 가상메모리를 같은 크기 단위(페이지 단위)로 분할했지만 세그멘테이션 기법은 가상메모리를 서로 다른 크기의 논리적 단위(세그먼트)로 분할해서 메모리를 할당하고 실제 메모리 주소로 변환한다.   
* 각 세그먼트는 연속적인 공간에 저장된다.   
* 세그먼트들의 크기가 서로 다르므로 미리 분할할 수는 없고 메모리에 적재시 빈 공간을 찾아 할당한다.   
* 가상메모리와 물리메모리의 맵핑을 위해 세그먼트 테이블이 필요하다.   
* 세그먼트 테이블은 각 세스먼트 항목별 세그먼트 시작주소와 세그먼트 길이 정보를 갖고 있다.   
* 필요한 메모리 만큼을 할당해주기 때문에 내부단편화는 일어나지 않으나 프로세스가 메모리를 해제하면 생기는 빈 공간, 즉 외부 단편화는 여전히 존재한다.(연속적인 공간을 할당하므로)   

### 메모리 풀
* 필요한 메모리 공간을 필요한 크기, 개수 만큼 사용자가 직접 지정하여 미리 할당받아 필요할 때마다 사용/반납하는 기법   
* 메모리 풀 없이 동적할당/해제를 반복하면 메모리의 랜덤한 위치에 메모리 할당 해제가 반복되면서 단편화를 일으킬 수 있지만 미리 공간을 할당하여 그 공간만 사용하고 반납하기 때문에   
* 할당/해제로 인한 외부 단편화가 발생하지 않는다.   
* 필요한 크기만큼 할당하기 때문에 내부 단편화가 발생하지 않는다.   
* 메모리 단편화로 낭비되는 메모리보다 사용하지 않는 메모리 풀 공간이 커질 경우 사용을 지양해야한다.   
* 메모리 할당/해제가 잦을 경우 메모리 풀을 쓰면 효율적이다.   
* 사용하지 않는 순간에도 메모리를 미리 할당해 놓으므로 역설적으로 메모리 누수 기반 방식이다.   


