# Thread의 생성과 소멸

출처 : '뇌를 자극하는 윈도우즈 시스템 프로그래밍' 

* 생성할 수 있는 스레드의 최대 개수?   
* => 메모리가 허용하는 만큼   
* 스레드가 생성될 때마다 독립된 스택을 할당해줘야 함, 즉, 스택을 할당할 수 있을 때까지 스레드 생성을 허용.   
* 기본 스택 사이즈는 1메가 바이트이다. (1024 x 1024) 이 때, 생성되는 스레드 개수는 2024개다.   
* 디폴트 스택 크기는 스레드에서 필요로 하는 최소한의 스택 크기이다.   
* CreateThread 함수에서 디폴트 스택 크기를 줄여도 생성되는 최대 스레드 개수는 같기때문    

## 스레드의 소멸
* 가장 이상적인 스레드 소멸 방법은 스레드 함수 내에서 return 문을 통해 종료하는 것이다.   
* 1. 스레드 종료시 return 을 이용하면 좋은 경우 (거의 대부분)   
=> 가장 일반적인 경우이며 외부로부터 입출력 작업이 많이 요구되어 Blocked 상태에 자주 놓이는 작업이 있다치자.   
=> 이 작업을 빨리 끝내기 위해 총 세 개의 스레드를 생성해 일의 부담을 나눠주자.   
=> 이럴 경우 정해진 시간 동안 CPU에게 보다 많은 일을 시킬 수 있고 Blocked 상태에 놓여도 세 개의 스레드가 나눠서 감당하기 때문에 속도가 높아질 확률이 높다.

* 스레드 종료시 ExitThread 함수 호출이 유용한 경우. 즉, 특정 위치에서 스레드 실행을 종료시키고자 하는 경우   
=> ExitThread 함수는 현재 실행중인 스레드를 종료하고자 할 때 호출하는 함수이며, return 방식의 스레드 종료 만큼이나 선호되는 편.   
=> 종료코드는 GetExitCodeThread를 통해 알 수 있으며, 장점은 언제 어디서나 스레드를 종료시키고, return 문 보다 코드를 이해하기 좋다.   
=> 그렇다면 return문은 언제 어디서나 스레드를 종료 시킬 수 없을까?    
=> 어떤 스레드 함수에서 3번의 함수를 중첩해서 실행했다면 return을 3번 해서 나와서 마지막까지 return해야 종료가 가능   
=> ExitThread 에 의한 종료 시점은 언제 어디서든 상관 없다. 그러나 주의할 점은 함수를 중첩해서 호출했을 경우 마지막 함수에서 ExitThread 함수를 호출했다면,   
=> 나머지 함수의 스택 프레임에 존재하는 객체의 소멸자는 호출되지 않는다.   
=> 따라서 메모리 릭 현상이 발생할 수도 있다.   
=> C, C++ 구분 없이 가장 좋은 방법은 return 문에 의한 스레드 종료이다.   

## 스레드 종료시 TerminateThread 함수 호출이 유용한 경우(외부에서 스레드를 종료)
* main 함수에서 스레드를 생성할 경우 해당 스레드  핸들을 얻게 되는데 이 핸들을 이용해서 Thread를 강제 종료시킬 수 있다.   
* 강제 종료는 할당받은 메모리나 리소스 해제를 처리하지 못하고 바로 종료되므로 문제가 있다고 인식되는 것이 보통   

## 스레드의 성격과 특성
* 힙, 데이터, 코드 영역의 공유   
* 스레드는 메모리를 공유한다. 특히 전역변수가 할당되는 데이터 영역, 메모리가 동적 할ㄹ당되는 힙 영역을 공유한다.   
* 문제점은 동시 접근이다. 즉, 경합상태   
* 실행중인 스레드의 변경은 프로그램 라인 단위로 일어나지 않는다.   
* printf, scanf, ++,--를 실행시키는 중에도 컨텍스트 스위칭은 발생   
* 따라서, 둘 이상의 스레드가 같은 메모리 영역을 동시에 참조하는 것은 경합 문제를 발생시킬 가능성이 높다.    

## 프로세스로부터 스레드의 분리
* 프로세스는 스레드를 담는 상자, 따라서 프로세스 핸들 테이블도 사실은 스레드의 핸들 테이블이 되어야 하지 않을까?   
* 스레드별로 핸들 테이블이 존재하지는 않고 핸들 테이블은 프로세스 소유이다.   
* 하나의 프로세스에 하나의 핸들 테이블이 존재   
* 프로세스 A가 리소스 파이프,메일슬롯 등을 생성하면서 얻은 핸들값이 204라고 치면 프로세스 B가 204라는 숫자로 A프로세스의 리소스에 접근할 수 있는 것은 아니다.   

