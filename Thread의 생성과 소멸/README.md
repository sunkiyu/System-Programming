# Thread의 생성과 소멸

출처 : '뇌를 자극하는 윈도우즈 시스템 프로그래밍' 

* 생성할 수 있는 스레드의 최대 개수?   
* => 메모리가 허용하는 만큼   
* 스레드가 생성될 때마다 독립된 스택을 할당해줘야 함, 즉, 스택을 할당할 수 있을 때까지 스레드 생성을 허용.   
* 기본 스택 사이즈는 1메가 바이트이다. (1024 x 1024) 이 때, 생성되는 스레드 개수는 2024개다.   
* 디폴트 스택 크기는 스레드에서 필요로 하는 최소한의 스택 크기이다.   
* CreateThread 함수에서 디폴트 스택 크기를 줄여도 생성되는 최대 스레드 개수는 같기때문    

## 스레드의 소멸
* 가장 이상적인 스레드 소멸 방법은 스레드 함수 내에서 return 문을 통해 종료하는 것이다.   
* 1. 스레드 종료시 return 을 이용하면 좋은 경우 (거의 대부분)   
=> 가장 일반적인 경우이며 외부로부터 입출력 작업이 많이 요구되어 Blocked 상태에 자주 놓이는 작업이 있다치자.   
=> 이 작업을 빨리 끝내기 위해 총 세 개의 스레드를 생성해 일의 부담을 나눠주자.   
=> 이럴 경우 정해진 시간 동안 CPU에게 보다 많은 일을 시킬 수 있고 Blocked 상태에 놓여도 세 개의 스레드가 나눠서 감당하기 때문에 속도가 높아질 확률이 높다.

* 스레드 종료시 ExitThread 함수 호출이 유용한 경우. 즉, 특정 위치에서 스레드 실행을 종료시키고자 하는 경우   
=> ExitThread 함수는 현재 실행중인 스레드를 종료하고자 할 때 호출하는 함수이며, return 방식의 스레드 종료 만큼이나 선호되는 편.   
=> 종료코드는 GetExitCodeThread를 통해 알 수 있으며, 장점은 언제 어디서나 스레드를 종료시키고, return 문 보다 코드를 이해하기 좋다.   
=> 그렇다면 return문은 언제 어디서나 스레드를 종료 시킬 수 없을까?    
=> 어떤 스레드 함수에서 3번의 함수를 중첩해서 실행했다면 return을 3번 해서 나와서 마지막까지 return해야 종료가 가능   
=> ExitThread 에 의한 종료 시점은 언제 어디서든 상관 없다. 그러나 주의할 점은 함수를 중첩해서 호출했을 경우 마지막 함수에서 ExitThread 함수를 호출했다면,   
=> 나머지 함수의 스택 프레임에 존재하는 객체의 소멸자는 호출되지 않는다.   
=> 따라서 메모리 릭 현상이 발생할 수도 있다.   
=> C, C++ 구분 없이 가장 좋은 방법은 return 문에 의한 스레드 종료이다.   

## 스레드 종료시 TerminateThread 함수 호출이 유용한 경우(외부에서 스레드를 종료)
* main 함수에서 스레드를 생성할 경우 해당 스레드  핸들을 얻게 되는데 이 핸들을 이용해서 Thread를 강제 종료시킬 수 있다.   
* 강제 종료는 할당받은 메모리나 리소스 해제를 처리하지 못하고 바로 종료되므로 문제가 있다고 인식되는 것이 보통   

## 스레드의 성격과 특성
* 힙, 데이터, 코드 영역의 공유   
* 스레드는 메모리를 공유한다. 특히 전역변수가 할당되는 데이터 영역, 메모리가 동적 할ㄹ당되는 힙 영역을 공유한다.   
* 문제점은 동시 접근이다. 즉, 경합상태   
* 실행중인 스레드의 변경은 프로그램 라인 단위로 일어나지 않는다.   
* printf, scanf, ++,--를 실행시키는 중에도 컨텍스트 스위칭은 발생   
* 따라서, 둘 이상의 스레드가 같은 메모리 영역을 동시에 참조하는 것은 경합 문제를 발생시킬 가능성이 높다.    

## 프로세스로부터 스레드의 분리
* 프로세스는 스레드를 담는 상자, 따라서 프로세스 핸들 테이블도 사실은 스레드의 핸들 테이블이 되어야 하지 않을까?   
* 스레드별로 핸들 테이블이 존재하지는 않고 핸들 테이블은 프로세스 소유이다.   
* 하나의 프로세스에 하나의 핸들 테이블이 존재   
* 프로세스 A가 리소스 파이프,메일슬롯 등을 생성하면서 얻은 핸들값이 204라고 치면 프로세스 B가 204라는 숫자로 A프로세스의 리소스에 접근할 수 있는 것은 아니다.   
* 핸들값은 핸들 테이블에 정보가 등록되고 핸들 테이블 소유자인 프로세스에게만 의미를 갖는다.   
* 프로세스 B의 핸들 테이블에는 204에 대한 정보가 없다. 따라서 접근 불가능하다.   
* 프로세스 A내에서 생성된 스레드들에게는 핸들 204가 의미를 지니는데 같은 프로세스에서 생성된 모든 스레드들은 스택 이외의 모든것을 공유하기 때문이다.   
* 핸들 테이블까지도 공유하고, Thread 생성시는 Usage Count가 2, 스레드 종료시 1감소, CloseHandle시 1감소한다.   
* 자식 프로세스가 생성되고 종료되어도 부모 프로세스가 물고있어 Usage Count가 1인어서 커널 오브젝트가 소멸안되는 현상이 스레드도 발생할 수 있다.   
* 이때는 스레드 생성시 반환된 핸들 값을 CloseHandle을 바로 호출하면 된다. 이렇게 하면 Usage Count가 바로 1이되고 스레드 종료와 동시에 Usage Count가 0이 되며 모든 메모리를 반환한다.   
* CloseHandle 함수 호출을 가르켜 프로세스로부터 스레드 분리한다. 라고 한다.   

## ANSI 표준 C 라이브러리와 쓰레드
* C라이브러리 함수는 멀티스레드에 대한 고려가 전혀 이루어지지 않음.    
* tprintf 함수는 C라이브러리 함수인데 멀티스레드 기반에서 문제를 일으키지 않으려면 스레드에 안전한 런타임 라이브러리를 선택해야하고   
* CreateThread 대신 beginthreadEx 함수를 사용해야함. 기능은 동일      
* 차이는 beginThreadEx 함수는 스레드 생성하기 앞서 스레드를 위한 독립적인 메모리 블록을 할당.    


## 쓰레드의 상태 변화
* Windows에서는 상태가 변화하는 주체가 프로세스가 아니라 쓰레드이지만 프로세스의 상태 변화와 다를 바 없다.   
* 스레드가 생성되자마자 Ready 상태에 놓인다. 스케줄러에 의해 선택될 경우 Running. Ready 상태의 스레드는 여럿이 될 수 있지만 Running 상태 스레드는 하나밖에 될 수 없음.  
* 실생중인 스레드가 타임 슬라이스가 모두 소진되어 다른 스레드에게 실행 기회를 넘길때는 Running->Ready 상태로 이동, Blocked 상태가 아닌다.      
* Running 상태 스레드가 입출력 연산이나 Sleep 함수로 잠시 실행 중단된 경우 Blocked 상태로 이동하며 다른 스레드 실행을 도모한다.   
* Blocked 원인이 끝나면 Ready 상태로 된다.   
 
## Suspend & Resume

* DWORD SuspendThread    
* Blocked 상태에 두고자 하는 쓰레드의 핸들을 인자로 전달한다   
* DWORD ResumeThread     
* Ready 상태에 두고자 하는 쓰레드의 핸들을 인자로 전달한다.   
첫번째 함수는 Blocked 상태에 두는 함수이다   
두번째 함수는 Blocked 상태에 있는 함수를 Ready 상태에 두기 위한 함수이다.   
* 스레드의 커널 오브젝트에 Suspended Count가 있어 suspend 두번이면 Resume도 두번해줘야 함.   

 ## 쓰레드의 우선순위 컨트롤
* 프로세스는 실행의 주체가 아닌 쓰레드를 담는 그릇에 불과하다.   
* 따라서 Windows에서는 프로세스가 우선순위를 갖는 것이 아니다.   
* 프로세스 안에서 동작하는 쓰레드가 우선순위를 갖는다.   
 
## 쓰레드의 우선순위는?
* 프로세스의 기준 우선순위와, 쓰레드의 상대적 우선순위의 조합으로 정해진다.   
* 즉, 프로세스의 기준 우선순위를 기준으로 해서 상대적 우선순위에 해당하는 값을 더하거나 빼면 쓰레드의 실질적인 우선순위를 계산해 낼 수 있다.   
* 우선순위 상수들은 Windows 버전별로 차이가 있다.    
* 프로세스 내에서 생성되는 모든 쓰레드의 상대적 우선순위는? 프로세스의 기준 우선순위를 그대로 수용하는 것이다.   




